---
marp: true
---




![w:220](docs/unicam.jpg)

#### Intermediate Evaluation
## From BPMN to Permissioned blockchains: A model-driven approach


Nizar Hmain - 2020

![bg right h:100](docs/hyperledger.png)

![bg right w:170](docs/sawtooth.png)

![bg right w:100](docs/quorum.png)


---


# Permissionless blockchain networks

- The problem
- Information gathered about the problem
- read crypto and blockchain papers
- what are some of the potential solutions
- read paper about solutions (hyperledger and quorum) 
- what technologies we considered


---

# The problem

The goal is to explore and concretize the problem of permissioned blockchains. The final objective would be to enhance the already previous research and work done on the ChorChain platform done by our Unicam collegues.

[chorchain paper link](http://pros.unicam.it/chorchain/)

---


# The chorchain project

Would essentially take a BPMN Choreographies and scaffold and runnable environment and spawn smart contracts, assiging roles to the actors.  

It solved the already very complex task of mapping BPMN into a solidity smart contract.

This work would be a parallel enhancement to this work

--- 

# Recap on Fundamentals of blockchains

- The data structure

- The cryptography behind it

- It's Decentralized/Distributed nature

- The consensus


---

![](docs/satoshi_diagram.png)


*From Satoshi's paper*


---



![](docs/linkedlist1.png)



--- 

# Cryptography in blockchains 

--- 


## How are we supposed to trust 

- There is this concept of global state in blockchains (we call it a ledger)
- The issue is that anyone can add a new line to it
- How do we differentiate between users ? 



---

We must add something that is unique to each entity or user. 

If Alice wants to send a transaction to Bob. We must make sure that it's unfeasable for anyone else to forge this transaction in her name.

This is where the concept of digital signatures comes in.


---

How do we prevent anyone from copying someones signature. We do so by generating a Private key / public Key pair.

![](docs/pka.png)


---

![](docs/signature.png)

![](docs/verify.png)


---


Both bitcoin and Ethereum use ECDSA for Public/private key encryption as their algorithm


Another type of public key cryptography that you may be familiar with is RSA, which utilizes prime number theorem (the security for this relies on the fact that we haven't come up with a way to efficiently, mathematically define the distribution of prime numbers) for computational complexity.

ECDSA, uses a different method for computational complexity called the Discrete Logarithm Problem which relies on the infeasible nature of determining the discrete logarithm of a random point on the defined elliptic curve.

One reason for using ECDSA as opposed to RSA, is that ECDSA has equivalent security to RSA while using smaller key sizes. 256-bit public key's computational complexity in ECDSA translate to roughly same the computational complexity of a 3072-bit public key for RSA.

--- 

Note: ECDSA is a digital signature scheme only used to sign transactions. Ethereum additionaly uses AES encryption for their p2p network, and ECIES for the message exchange within whisper.


*Whisper : Whisper is a part of the Ethereum P2P protocol suite that allows for messaging between users via the same network that the blockchain runs on.*

--- 




## Common loopholes with these concepts


### Forgery defence mechanisms
- PKA cryptography does in fact stop copying transactions. But it doesn't stop someone from copying exactly the same message with it's signature and replicating it.

-  if alice sends bob 20$, and the signature is 001101 
-  if alice sends bob 20$, and the signature is 001101 

We add tx_ids to ensure uniqueness 

- tx=1 if alice sends bob 20$, and the signature is 001101 
- tx=2 if alice sends bob 20$, and the signature is 100001
- so in the message we must add a unique ID, that would change the message payload and therefore change the signature as well.


---


### Overspending
- Verifying a transaction requires you to know all the history of the transactions up to that point. That's how we stop overspending.



---


# Decentralized / Distributed


While a blockchain is inherently distributed (meaning that many parties hold copies of the ledger), it is not inherently decentralized. Whether a blockchain is centralized or decentralized simply refers to the rights of participants on the ledger, and is therefore a question of design.


---

![](docs/networks.png)


---


The most important difference to remember is that blockchain is just one type of distributed ledger. Although blockchain is a sequence of blocks, distributed ledgers do not require such a chain. Furthermore, distributed ledgers do not need proof of work and offer – theoretically – better scaling options.

Removing the intermediary party from the equation is what makes the concept of distributed ledger technology so appealing. Unlike blockchain, a distributed ledger does not necessarily need to have a data structure in blocks. A distributed ledger is merely a type of database spread across multiple sites, regions, or participants.


--- 






--- 

### how does eth guarantees account uniqueness, even with offline

Ethereum addresses are 160 bit hashes, meaning there are 2^160 possible hashes. Per the birthday problem, the chance of a collision rises to 50% when there are about 2^80 accounts created.

To give you an idea of how unlikely that is, if every person on earth spent all their time doing nothing but generating Ethereum accounts, and they generated one a second, they'd only generate about 2^57 of them. To generate 2^80 and reach a 50% probability of finding a collision, they'd need to keep on generating one per second for about 8 million years.

In short, the way Ethereum guarantees account uniqueness is by having such a mindbogglingly large number of possible addresses that no conceivable random process could ever generate a duplicate. This is also how account security is ensured - if you can generate a duplicate key hash, you can also steal someone's ether!



### how do we find other nodes and peers


Bootnode is a lightweight application used for the Node Discovery Protocol. Bootnodes do not sync chain data. Using a UDP-based Kademlia-like RPC protocol, Ethereum will connect and interrogate these bootnodes for the location of potential peers.

## blockchain section


### raft consensus algorithm

Raft visualization
http://thesecretlivesofdata.com/raft/

### p2p discovery

https://en.wikipedia.org/wiki/Kademlia  

https://github.com/ethereum/devp2p/wiki/Discovery-Overview



# What does it solve



# How it solves our particular case
## Narrowing down the perspective






# The tech

## hyperledger sawtooth



## quorum








